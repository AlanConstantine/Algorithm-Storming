# 在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。

# 如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；

# 而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。


# 给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。


# // 我们先看一颗正常的二叉树
# // 第1行: [1]
# // 第2行: [2]                                     [3]
# // 第3行: [4]                 [5]                 [6]                 [7]
# // 第4行: [8]       [9]       [10]      [11]      [12]      [13]      [14]      [15]
# // 第5行: [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [26] [27] [28] [29] [30] [31]
# // ...
# // 可以总结出一些简单的规律:
# // 对于第i行(依照题意这里我们的i从1开始取, 当然也可以从0开始取):
# // 1. 起始节点值begin_label(i) = 2^(i-1), [(i -> begin_label(i))] => [(1 -> 1), (2 -> 2), (3 -> 4), (4 -> 8), (5 -> 16), ... , (i -> 2^(i-1))]
# // 2. 结束节点值end_label(i) = 2^i - 1,   [(i -> end_label(i))]   => [(1 -> 1), (2 -> 3), (3 -> 7), (4 -> 15), (5 -> 31), ... , (i -> 2^i -1)]
# // 3. 行内节点个数label_cnt(i) = 2^(i-1)  [(i -> label_cnt(i))]   => [(1 -> 1), (2 -> 2), (3 -> 4), (4 -> 8), (5 -> 16), ... , (i -> 2^(i-1))]
# // 4. 行内节点值总和sum(i) = begin_label(i) + (begin_label(i) + 1) + (begin_label(i) + 2) + ... + end_label(i)
# //                      = 也就是以begin_label(i)为首项, end_label(i)为末项, 1为公差的等差数列的和
# //                      = 行内节点总数 * (行首值 + 行末值) / 2 => S(n) = 项数n * (首项a1 + 末项an) / 2
# //                      = label_cnt(i) * (begin_label(i) + end_label(i)) / 2
# // 对于某节点label:
# // 0. 所在行数i(label) = int(log2(label)) + 1 (以2为底label的对数 向下取整 加1)
# // 1. 父节点parent(label) = label / 2
# // 2. 左子节点left_child(label) = label * 2
# // 3. 柚子节点right_child(label) = label * 2 + 1
# // 由上我们可以看出, 如果对于正常的二叉树寻根路径, 我们只要不停地对值除2即可

# // 下面我们看看不正常的二叉树:
# // 第1行: [1]
# // 第2行: [3]                                     [2]    <-  逆序
# // 第3行: [4]                 [5]                 [6]                 [7]
# // 第4行: [15]      [14]      [13]      [12]      [11]      [10]      [9]       [8]  <- 逆序
# // 第5行: [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [26] [27] [28] [29] [30] [31]
# // ...
# // 我们继续尝试总结一些规律:
# // 对于第i行(依照题意这里我们的i从1开始取, 当然也可以从0开始取):
# // 1. 起始节点值begin_label(i)为:
# //    1.1. 对于奇数行(i%2 == 1): begin_label(i) = 2 ^ (i-1) 与正常情况一致
# //    1.2. 对于偶数行(i%2 == 0): begin_label(i) = 2^i - 1   是正常情况下的结束节点值
# // 2. 结束节点值end_label(i)为:
# //    2.1. 对于奇数行(i%2 == 1): end_label(i) = 2^i - 1     与正常情况一致
# //    2.2. 对于偶数行(i%2 == 0): end_label(i) = 2 ^ (i-1)   是正常情况下的起始节点值
# // 3. 行内节点数label_cnt(i) = 2 ^ (i-1) 与正常情况一致
# // 4. 对于行内节点值总和sum(i), 因为相比较正常情况, 仅仅是偶数行的顺序变为逆序, 而每一行的数字内容不变, 所以行内节点总和与正常情况相同

# // 对于某节点label:
# // 0. 所在行数i(label) = int(log2(label)) + 1 (以2为底label的对数, 向下取整, 加1)
# // 1. 父节点parent(label):
# //    1.1 对于奇数行(i%2 == 1): parent(label) = (pair(i) - label) / 2
# //    1.2 对于偶数行(i%2 == 0): parent(label) = (pair(i) - label) / 2
# // 这就很神奇了呀, 我们发现不论奇数行还是偶数行, 最后的parent计算公式是一样的, 那这个pair(i)是个啥呢:
# // pair(i) = begin_label(i) + end_label(i) (也就是每一行的行首与行末的和)
# // 以第4行为例: pair(4) = 23 = 15 + 8 = 14 + 9 = 13 + 10 = 12 + 11
# // 有了这个pair(i), 我们就能快速的计算出逆序时它原序所对应的值
# // 以第4行的13为例: 13的父节点是5, 但我们不能直接用13 / 2, 因为13所在行是反序的, 我们需要将13映射成10以后再除2, 这时候答案就对了
# // 再以第3行的5为例: 5的父节点是3, 但我们不能直接用5 / 2, 因为它的父节点3所在行是反序的, 我们需要将5映射为6以后再除2, 这时候答案就对了
# // 很神奇是不是, 不论当前行是正序还是反序, 我们都需要将当前数字label映射为pair(i)-label 后再除2
# // 我又发现pair(i) = pair(i-1) * 2 + 1
# cited from 鲤鱼: https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-rw2d/


import math
# 对于正常的层序遍历，父节点下标 = 当前节点下标/2
# 对于之字形遍历，由于隔层反向，故 父节点下标 = 当前节点的对称节点下标/2
# 由归纳可知，当前节点的对称节点下标 = 当前层的最大下标 + 当前层的最小下标 - 当前节点的下标
# 其中，当前层的最小下标 = 上一层的最大下标+1

# 作者：fan-hang-9
# 链接：https: // leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/solution/zui-yi-dong-de-si-lu-jie-jue-zai-bu-tong-zk3j/
# 来源：力扣（LeetCode）


class Solution:
    def pathInZigZagTree(self, label: int):
        row = int(math.log2(label))+1  # 根据数学规律利用label定位行数
        ans = [0]*row  # 一行一个父节点，所以ans有row维
        while row:
            ans[row-1] = label  # 将当前label加入到ans中
            label = (2**row-1-label+2**(row-1))//2  # 找出label的父节点
            row -= 1  # 行号-1

        return ans


print(Solution().pathInZigZagTree(26))
